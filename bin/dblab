#!/bin/bash

# bin/dblab - Main dblab CLI entry point
# Provides unified interface for database container management

set -euo pipefail

# Get script directory and source core utilities
# Handle symlinks properly
if [[ -L "${BASH_SOURCE[0]}" ]]; then
    # Script is a symlink, resolve it
    SCRIPT_PATH="$(readlink -f "${BASH_SOURCE[0]}")"
else
    SCRIPT_PATH="${BASH_SOURCE[0]}"
fi
SCRIPT_DIR="$(cd "$(dirname "$SCRIPT_PATH")" && pwd)"
PROJECT_DIR="$(dirname "$SCRIPT_DIR")"
CORE_DIR="${PROJECT_DIR}/core"
ENGINES_DIR="${PROJECT_DIR}/engines"

# Source core modules
source "${CORE_DIR}/lib.sh"
source "${CORE_DIR}/env_loader.sh"
source "${CORE_DIR}/detect_engine.sh"
source "${CORE_DIR}/env_template.sh"
source "${CORE_DIR}/command_dispatcher.sh"

# Global variables for command line parsing
COMMAND=""
ENGINE=""
INSTANCE=""
ENV_FILES=()
CLI_OVERRIDES=()
DEBUG_MODE="false"
HELP_MODE="false"
VERBOSE_MODE="false"
EXPOSE_PORTS=""
COMMAND_ARGS=()

# Show usage information
show_usage() {
    cat << EOF
dblab - Database container management tool

USAGE:
    dblab <command> <engine> [options]
    dblab <global-command> [options]

COMMANDS:
    init <engine>     Generate template env file for instance
    up <engine>       Start database instance
    down <engine>     Stop database instance
    status <engine>   Show instance status
    cli <engine>      Connect to database CLI/shell
    destroy <engine>  Remove instance and all data (destructive)
    list <engine>     List instances for engine
    list <engine> -v  List instances with detailed information
    help              Show this help message

ENGINES:
    postgres          PostgreSQL database
    sqlserver         Microsoft SQL Server database

GLOBAL OPTIONS:
    --instance, -i <name>    Instance name (required for most commands)
    --env-file <path>        Load environment from file (can be used multiple times)
    --expose <port[:port]>   Expose port(s) to host (format: 5432 or 5432:5432)
    --verbose, -v            Show detailed information (for list command)
    --debug                  Enable debug logging
    --help, -h               Show help message

EXAMPLES:
    # Start PostgreSQL instance with env file
    dblab up postgres --instance pg16 --env-file pg16.env
    
    # Start PostgreSQL instance with port exposure
    dblab up postgres --instance pg16 --env-file pg16.env --expose 5432
    
    # Start with custom port mapping
    dblab up postgres --instance pg16 --env-file pg16.env --expose 15432:5432
    
    # Connect to PostgreSQL CLI
    dblab cli postgres --instance pg16 --env-file pg16.env
    
    # Connect to SQL Server CLI with query
    dblab cli sqlserver --instance mssql2022 --env-file mssql2022.env -Q "SELECT @@VERSION"
    
    # Stop PostgreSQL instance
    dblab down postgres --instance pg16
    
    # Check status
    dblab status postgres --instance pg16
    
    # Destroy instance (removes all data)
    dblab destroy postgres --instance pg16
    
    # List all postgres instances
    dblab list postgres
    
    # List with detailed information
    dblab list postgres --verbose

ENVIRONMENT VARIABLES:
    DBLAB_LOG_LEVEL          Log level (error|warn|info|debug|trace)
    DBLAB_BASE_DIR           Base directory for data storage
    CONTAINER_BACKEND        Container runtime (podman|docker)

For more information, see the documentation.
EOF
}

# Parse command line arguments  
parse_args() {
    local remaining_args=()
    
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --help|-h)
                HELP_MODE="true"
                return 0
                ;;
            --debug)
                DEBUG_MODE="true"
                export DBLAB_LOG_LEVEL="debug"
                shift
                ;;
            --instance|-i)
                if [[ $# -lt 2 ]]; then
                    die "Option $1 requires an argument"
                fi
                INSTANCE="$2"
                shift 2
                ;;
            --env-file|-e)
                if [[ $# -lt 2 ]]; then
                    die "Option $1 requires an argument"
                fi
                ENV_FILES+=("$2")
                shift 2
                ;;
            --verbose|-v)
                VERBOSE_MODE="true"
                shift
                ;;
            --expose)
                if [[ $# -lt 2 ]]; then
                    die "Option $1 requires an argument"
                fi
                EXPOSE_PORTS="$2"
                shift 2
                ;;
            --*)
                # Check if we have command and engine already set
                if [[ -n "$COMMAND" && -n "$ENGINE" ]]; then
                    # This is a command-specific option, collect remaining args
                    remaining_args+=("$@")
                    break
                else
                    die "Unknown option: $1"
                fi
                ;;
            *)
                # First non-option argument is the command
                if [[ -z "$COMMAND" ]]; then
                    COMMAND="$1"
                    shift
                # Second non-option argument is the engine (for most commands)
                elif [[ -z "$ENGINE" && "$COMMAND" != "help" ]]; then
                    ENGINE="$1"
                    shift
                else
                    # All remaining arguments are command-specific
                    remaining_args+=("$@")
                    break
                fi
                ;;
        esac
    done
    
    # Store remaining args in a global variable for main function
    COMMAND_ARGS=("${remaining_args[@]}")
}

# Validate command line arguments
validate_args() {
    if [[ "$HELP_MODE" == "true" || "$COMMAND" == "help" ]]; then
        return 0
    fi
    
    if [[ -z "$COMMAND" ]]; then
        die "Command is required. Use 'dblab help' for usage information."
    fi
    
    case "$COMMAND" in
        up|down|status|destroy|init|diag)
            if [[ -z "$ENGINE" ]]; then
                die "Engine is required for command '$COMMAND'"
            fi
            
            if [[ -z "$INSTANCE" ]]; then
                die "Instance name is required for command '$COMMAND'. Use --instance <name>"
            fi
            ;;
        cli|exec|gui|list|init-cli)
            if [[ -z "$ENGINE" ]]; then
                die "Engine is required for command '$COMMAND'"
            fi
            ;;
        *)
            die "Unknown command: $COMMAND. Use 'dblab help' for usage information."
            ;;
    esac
    
    # Validate engine if provided
    if [[ -n "$ENGINE" ]]; then
        validate_engine "$ENGINE"
    fi
    
    # Validate instance name if provided
    if [[ -n "$INSTANCE" ]]; then
        validate_instance_name "$INSTANCE"
    fi
    
    # Validate env files exist
    for env_file in "${ENV_FILES[@]}"; do
        if [[ ! -f "$env_file" ]]; then
            die "Environment file not found: $env_file"
        fi
    done
}

# Main execution function
main() {
    # Initialize logging
    init_dblab
    
    # Parse command line arguments
    parse_args "$@"
    
    # Show help if requested
    if [[ "$HELP_MODE" == "true" || "$COMMAND" == "help" ]]; then
        show_usage
        exit 0
    fi
    
    # Validate arguments
    validate_args
    
    # Set up error handling
    trap_error
    
    log_debug "Command: $COMMAND, Engine: $ENGINE, Instance: $INSTANCE"
    log_debug "Environment files: ${ENV_FILES[*]}"
    log_debug "Command-specific arguments: ${COMMAND_ARGS[*]}"
    
    # Execute command
    case "$COMMAND" in
        init|up|down|status|diag|destroy|list)
            dblab_dispatch_command \
                "$COMMAND" \
                "$ENGINE" \
                "$INSTANCE" \
                "${ENV_FILES[@]}" \
                -- \
                "${COMMAND_ARGS[@]}"
            ;;
        init-cli|cli|exec|gui)
            dblab_dispatch_client_command \
                "$COMMAND" \
                "$ENGINE" \
                "$INSTANCE" \
                "${ENV_FILES[@]}" \
                -- \
                "${COMMAND_ARGS[@]}"
            ;;
        *)
            die "Internal error: Unknown command: $COMMAND"
            ;;
    esac
    
    log_debug "Command completed successfully"
}

# Run main function
main "$@"
